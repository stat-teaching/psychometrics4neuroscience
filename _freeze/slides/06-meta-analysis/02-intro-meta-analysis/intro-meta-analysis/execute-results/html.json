{
  "hash": "27c74111316e87fe0e291fa8b920a9aa",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introduction to Meta-Analysis\"\nexecute: \n  echo: true\nknitr:\n  opts_chunk: \n    collapse: true\n    comment: \"#>\"\n---\n\n\n\n\n\n\n\n# Meta-analysis {.section}\n\n## Meta-analysis\n\n- The meta-analysis is a statistical procedure to combine evidence from a group of studies.\n\n. . .\n\n- The idea is to \"switch\" the statistical unit from e.g., participants to studies\n\n. . .\n\n- The motto could be that (appropriately) combining similar studies with a similar aim is the best way to understand something about a phenomenon\n\n## Meta-analysis and Systematic Review {.smaller}\n\nUsually a meta-analysis work follows these steps:\n\n1. **Identify the research question**: is the treatment *x* effective?, Does the experimental effect *y* exist?\n2. **Define inclusion/exclusion criteria**: From the research question (1), keep only e.g., randomized controlled trials, studies with healthy participants, etc.\n3. **Systematically search for studies**: Analyze the literature to find all relevant studies\n4. **Extract relevant information**: Read, extract and organize relevant information e.g., sample size, treatment type, age, etc.\n5. **Summarize the results**: Create a narrative (flowcharts, tables, etc.) summary of included studies. This is the Systematic review part.\n6. **Choose an effect size**: Choose a way to standardize the effect across included studies\n7. **Meta-analysis model**: Choose and implement a meta-analysis model\n8. **Interpret and report results**\n\n## Before the fun part...\n\n::: {.incremental}\n- We are dealing only with the **statistical part**. The study selection, data extraction, studies evaluation etc. is another story\n- The quality of the meta-analysis is the **quality of included studies**\n:::\n\n. . .\n\n![](img/gigo.png){fig-align=\"center\" width=60%}\n\n## Unstandardized effect sizes\n\nThe basic idea of an effect size is just using the raw measure. For example studies using reaction times we can calculate the difference between two conditions as $\\overline X_1 - \\overline X_2$:\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](intro-meta-analysis_files/figure-revealjs/unnamed-chunk-1-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n## Unstandardized effect sizes\n\nBut another study (with the same research question) could use another measure, e.g., accuracy. We can still (not the best strategy but) compute the difference between the group means.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](intro-meta-analysis_files/figure-revealjs/unnamed-chunk-2-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n\n## Unstandardized effect sizes\n\nClearly we cannot directly compare the two effects but we need to standardize the measure.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](intro-meta-analysis_files/figure-revealjs/unnamed-chunk-3-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n## Standardized effect sizes\n\nTo compare results from different studies, we should use a common metric. Frequently meta-analysts use *standardized* effect sizes. For example the Pearson correlation or the Cohen's $d$.\n\n$$\nr = \\frac{\\sum{(x_i - \\bar{x})(y_i - \\bar{y})}}{\\sqrt{\\sum{(x_i - \\bar{x})^2}\\sum{(y_i - \\bar{y})^2}}}\n$$ {#eq-correlation}\n\n$$\nd = \\frac{\\bar{x_1} - \\bar{x_2}}{s_p}\n$$\n\n$$\ns_p = \\sqrt{\\frac{(n_1 - 1)s_1^2 + (n_2 - 1)s_2^2}{n_1 + n_2 - 2}}\n$$\n\n## Standardized effect sizes\n\nThe advantage of standardized effect size is that regardless the original variable, the interpretation and the scale is the same. For example the pearson correlation ranges between -1 and 1 and the Cohen's $d$ between $- \\infty$ and $\\infty$ and is interpreted as how many standard deviations the two groups/conditions differs.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nS <- matrix(c(1, 0.7, 0.7, 1), nrow = 2)\nX <- MASS::mvrnorm(100, c(0, 2), S, empirical = TRUE)\n\npar(mfrow = c(1,2))\nplot(X, xlab = \"x\", ylab = \"y\", cex = 1.3, pch = 19,\n     cex.lab = 1.2, cex.axis = 1.2,\n     main = latex2exp::TeX(sprintf(\"$r = %.2f$\", cor(X[, 1], X[, 2]))))\nabline(lm(X[, 2] ~ X[, 1]), col = \"firebrick\", lwd = 2)\n\n\nplot(density(X[, 1]), xlim = c(-5, 7), ylim = c(0, 0.5), col = \"dodgerblue\", lwd = 2,\n     main = latex2exp::TeX(sprintf(\"$d = %.2f$\", lsr::cohensD(X[, 1], X[, 2]))),\n     xlab = \"\")\nlines(density(X[, 2]), col = \"firebrick\", lwd = 2)\n```\n\n::: {.cell-output-display}\n![](intro-meta-analysis_files/figure-revealjs/unnamed-chunk-4-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n## Standardized vs unstandardized\n\nThe main difference is (usually) the absence of a effect-size-variance relationship for unstandardized effects. For example, the variance of the difference between two groups is:\n\n$$\nV_d = \\frac{s^2_1}{n_1} + \\frac{s^2_2}{n_2}\n$$ {#eq-var-umd}\n\nWhile the variance of a Cohen's $d$ can be calculated as:\n\n$$\nV_d = \\frac{n_1 + n_2}{n_1 n_2} + \\frac{d^2}{2(n_1 + n_2)}\n$$\n\n## Standardized vs unstandardized\n\nIn this [amazing blog post](https://www.jepusto.com/alternative-formulas-for-the-smd/) James Pustejovsky explained where the equations comes from. Basically, the $\\frac{n_1 + n_2}{n_1 n_2}$ term is the same as the $\\frac{s^2_1}{n_1} + \\frac{s^2_2}{n_2}$ while the extra $\\frac{d^2}{2(n_1 + n_2)}$ is for the non-centrality induced by the standardized difference.\n\n## Standardized vs unstandardized\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nn <- c(10, 50, 100)\nd <- seq(0, 2, 0.001)\n\ndd <- expand.grid(n = n, d = d)\n\ndd$vumd <- with(dd, 1/n + 1/n)\ndd$vd <- with(dd, (n + n) / (n * n) + d^2/(2 * (n + n)))\n\ntidyr::pivot_longer(dd, 3:4) |> \n  ggplot(aes(x = d, y = value, color = name, linetype = factor(n))) +\n  geom_line() +\n  labs(linetype = \"Sample Size\",\n       color = NULL)\n```\n\n::: {.cell-output-display}\n![](intro-meta-analysis_files/figure-revealjs/unnamed-chunk-5-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n## Effect size sampling variability {#sec-effsize-se}\n\nCrucially, we can calculate also the **sampling variability** of each effect size. The **sampling variability** is the precision of estimated value.\n\nFor example, there are multiple methods to estimate the Cohen's $d$ sampling variability. For example:\n\n$$\nV_d = \\frac{n_1 + n_2}{n_1 n_2} + \\frac{d^2}{2(n_1 + n_2)}\n$$\n\nEach effect size has a specific formula for the sampling variability. The sample size is usually the most important information. Studies with higher sample size have lower sampling variability.\n\n## Effect size sampling variability\n\nAs the sample size grows and tends to infinity, the sampling variability approach zero.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](intro-meta-analysis_files/figure-revealjs/unnamed-chunk-6-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n## Unstandardized effect sizes\n\nFor the examples and plots I'm going to use simulated data. We simulate *unstandardized* effect sizes (UMD) because the computations are easier and the estimator is unbiased [e.g., @Viechtbauer2005-zt]\n\nMore specifically we simulate hypothetical studies where two independent groups are compared:\n\n$$\n\\Delta = \\overline{X_1} - \\overline{X_2}\n$$ {#eq-umd}\n\n$$\nSE_{\\Delta} = \\sqrt{\\frac{s^2_1}{n_1} + \\frac{s^2_2}{n_2}}\n$$\n\nWith $X_{1_i} \\sim \\mathcal{N}(0, 1)$ and $X_{2_i} \\sim \\mathcal{N}(\\Delta, 1)$\n\nThe main advantage is that, compared to standardized effect size, the sampling variability do not depends on the effect size itself, simplifying the computations.\n\n# Simulating a single study {.section}\n\n## Simulating a single study - UMD\n\nTo simulate a single study using a UMD we need to generate data according to the appropriate model. Here we have a difference between two groups. We can assume that the two groups comes from a normal distribution where group 1 $g_1 \\sim \\mathcal{N}(0, 1)$ and group 2 $g_2 \\sim \\mathcal{N}(D, 1)$ where $D$ is the effect size. Then using Equations [-@eq-var-umd; -@eq-umd] we can estimate the effect size and the variance.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nD <- 1  # effect size\nn <- 50 # sample size\ng1 <- rnorm(n, mean = 0, sd = 1)\ng2 <- rnorm(n, mean = D, sd = 1)\n\n# effect size\nmean(g2) - mean(g1)\n#> [1] 0.7525521\n\n# variance\nvar(g1)/n + var(g2)/n\n#> [1] 0.04732674\n```\n:::\n\n\n\n## Simulating a single study - UMD\n\nFor simplicity we can wrap everything within a function:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# default sd = 1\nsim_umd <- function(n1, n2 = NULL, D, sd = 1){\n  if(is.null(n2)) n2 <- n1 # same to n1 if null \n  g1 <- rnorm(n1, mean = 0, sd = sd)\n  g2 <- rnorm(n2, mean = D, sd = sd)\n  yi <- mean(g2) - mean(g1)\n  vi <- var(g1)/n1 + var(g2)/n2\n  data.frame(yi, vi)\n}\n\nsim_umd(100, D = 0.5)\n#>          yi         vi\n#> 1 0.5779448 0.01802745\nsim_umd(50, D = 0.1)\n#>           yi         vi\n#> 1 0.01265824 0.04348705\n```\n:::\n\n\n\n## Simulating a single study - UMD\n\nWe can also generate a large number of studies and check the distribution of effect size and sampling variances. Note that the real $D = 1$ and the real variance $V_D = 1/50 + 1/50 = 0.04$\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstudies <- replicate(1000, sim_umd(n1 = 50, D = 1), simplify = FALSE) # simplify = FALSE return a list\nstudies <- do.call(rbind, studies) # to dataframe\nhead(studies)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>          yi         vi\n#> 1 1.0297445 0.03928089\n#> 2 0.8790549 0.03991526\n#> 3 1.0135863 0.04407775\n#> 4 1.1086738 0.03915357\n#> 5 1.2811220 0.04387874\n#> 6 1.1326733 0.02765962\n```\n\n\n:::\n:::\n\n\n\n## Simulating a single study - UMD {#sec-umd-sampling-distribution}\n\nThen we can plot the sampling distributions:\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](intro-meta-analysis_files/figure-revealjs/unnamed-chunk-10-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n## Simulating a single study - SMD\n\nThe idea is the same when simulating a SDM but we need extra steps. Let's adjust the previous function:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsim_smd <- function(n1, n2 = NULL, D){\n  if(is.null(n2)) n2 <- n1 # same to n1 if null \n  g1 <- rnorm(n1, mean = 0, sd = 1)\n  g2 <- rnorm(n2, mean = D, sd = 1)\n  \n  v1 <- var(g1)\n  v2 <- var(g2)\n  \n  # pooled standard deviation\n  sp <- sqrt((v1 * (n1 - 1) + v2 * (n2 - 1)) / (n1 + n2 - 2))\n  \n  yi <- (mean(g2) - mean(g1)) / sp\n  vi <- (n1 + n2) / (n1 * n2) + yi^2/(2*(n1 + n2))\n  data.frame(yi, vi)\n}\n```\n:::\n\n\n\n## Simulating a single study - SMD\n\nWhen working with SMD, calculating the sampling variance can be challenging. @Veroniki2016-nw identified 16 different estimators with different properties. Furthermore, it is a common practice to correct the SDM effect and variance using the Hedges's correction [@Hedges1989-ip]. \n\nYou can directly implement another equation for the sampling variance or the Hedges's correction directly in the simulation function.\n\n## Simulating a single study - Pearson $\\rho$\n\nAnother common effect size is the Pearson correlation coefficient $\\rho$ (and the estimate $r$, see @eq-correlation). The variance of the correlation is calculated as:\n\n$$\nV_{r} = \\frac{(1 - r^2)^2}{n - 1}\n$$\n\n## Simulating a single study - Pearson $\\rho$\n\nThere is a huge dependency between $r$ and it's sampling variance (similar to the Cohen's $d$):\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nn <- 50\nr <- seq(0, 1, 0.01)\nv <- (1 - r^2)^2 / (n - 1) \n\nplot(r, v, type = \"l\", main = \"N = 50\", xlab = \"r\", ylab = latex2exp::TeX(\"$V_r$\"))\n```\n\n::: {.cell-output-display}\n![](intro-meta-analysis_files/figure-revealjs/unnamed-chunk-12-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n## Simulating a single study - Pearson $\\rho$\n\nFor this reason the so-called Fisher's $z$ transformation is used to stabilize the relationship.\n\n$$\nz = \\frac{\\log{\\frac{1 + r}{1 - r}}}{2}\n$$\n\n$$\nV_z = \\frac{1}{n - 3}\n$$\n\nNow the variance is completely independent from the correlation value.\n\n## Simulating a single study - Pearson $\\rho$\n\nThis is the relationship between $r$ and $z$:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nn <- 50\nr <- seq(-1, 1, 0.01)\nv <- (1 - r^2)^2 / (n - 1) \nz <- log((1 + r)/(1 - r))/2\n\nplot(z, r, type = \"l\", xlab = \"Fisher's z\", ylab = \"Correlation\", main = \"Correlation to Fisher's z\")\n```\n\n::: {.cell-output-display}\n![](intro-meta-analysis_files/figure-revealjs/unnamed-chunk-13-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n## Simulating a single study - Pearson $\\rho$\n\nTo simulate a study using correlations we can use the `MASS::mvrnorm()` function that can generate correlated data from a multivariate normal distribution.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsim_r <- function(n, r){\n  R <- r + diag(1 - r, nrow = 2) # 2 x 2 correlation matrix\n  X <- MASS::mvrnorm(n, mu = c(0, 0), Sigma = R) # the means are not relevant here\n  r <- cor(X)[1, 2] # extract correlation\n  vr <- (1 - r^2)^2 / (n - 1)  # variance of r\n  yi <- log((1 + r)/(1 - r))/2 # fisher z\n  vi <- 1 / (n - 3) # fisher z variance\n  data.frame(yi, vi, r, vr) # including also the pearson correlation and variance\n}\n```\n:::\n\n\n\n## Simulating a single study - Pearson $\\rho$\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsim_r(100, 0.5)\n#>          yi         vi         r          vr\n#> 1 0.4011993 0.01030928 0.3809746 0.007381644\nsim_r(50, 0.8)\n#>         yi        vi         r          vr\n#> 1 1.102976 0.0212766 0.8015655 0.002608184\n\n# also here the sampling distributions\nstudies <- replicate(1000, sim_r(50, 0.7), simplify = FALSE)\nstudies <- do.call(rbind, studies)\nsummary(studies)\n#>        yi               vi                r                vr          \n#>  Min.   :0.4892   Min.   :0.02128   Min.   :0.4536   Min.   :0.001323  \n#>  1st Qu.:0.7616   1st Qu.:0.02128   1st Qu.:0.6420   1st Qu.:0.004001  \n#>  Median :0.8629   Median :0.02128   Median :0.6978   Median :0.005373  \n#>  Mean   :0.8648   Mean   :0.02128   Mean   :0.6913   Mean   :0.005654  \n#>  3rd Qu.:0.9650   3rd Qu.:0.02128   3rd Qu.:0.7465   3rd Qu.:0.007051  \n#>  Max.   :1.3065   Max.   :0.02128   Max.   :0.8634   Max.   :0.012875\n```\n:::\n\n\n\n## More on effect sizes\n\nThe same logic can be applied to any situation. Just understand the data generation process, find the effect size equations and generate data.\n\n- @Borenstein2009-mo for all effect sizes equations. Also with equations to convert among effect sizes (useful in real-world meta-analyses)   \n- the [`metafor::escalc()`](https://wviechtb.github.io/metafor/reference/escalc.html) function implements basically any effect size. You can see also the [source code](https://github.com/wviechtb/metafor/blob/master/R/escalc.r) to see the actual R implementation.\n- [Guide to effect sizes](https://matthewbjane.quarto.pub/guide-to-effect-sizes-and-confidence-intervals): a modern and complete overview of effect sizes\n\n## Simulating from sampling distributions \n\nThe previous simulation examples are participant-level simulations. In fact we simulated $n$ observations then we aggregated calculating the effect sizes.\n\n. . .\n\nThis is the most flexible and general data simulation strategy but is computationally not efficient.\n\n. . .\n\nAnother strategy individuate the exact effect size sampling distribution. Then we can sample directly from it. The downside is that we need to derive (or find) the equation.\n\n## Simulating from sampling distributions \n\nFor example, when generating UMD we can simulate from the sampling distribution presented in @sec-umd-sampling-distribution.\n\n$$\ny_i \\sim \\mathcal{N}(\\theta, \\sqrt{\\sigma^2_i})\n$$\n$$\n\\sigma^2_i \\sim \\frac{\\chi^2_{n_1 + n_2 - 2}}{n_1 + n_2 - 2} (\\frac{1}{n_1} + \\frac{1}{n_2})\n$$\n\nIn this way we can sample $k$ effects and sampling variances directly from the sampling distributions. Without generating data and then aggregate.\n\n## Simulating from sampling distributions \n\nWe can again put everything within a function:\n\n```r\nsim_k_umd <- function(k, D, n1, n2 = NULL){\n  if(is.null(n2)) n2 <- n1\n  yi <- rnorm(k, D, sqrt(1/n1 + 1/n2))\n  vi <- (rchisq(k, n1 + n2 - 2) / (n1 + n2 - 2)) * (1/n1 + 1/n2)\n  data.frame(yi, vi)\n}\n```\n\n## Simulating from sampling distributions \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsim_k_umd(k = 10, D = 0.5, n1 = 50)\n#>           yi         vi\n#> 1  0.3996257 0.03693858\n#> 2  0.4423115 0.03663911\n#> 3  0.6478248 0.04068844\n#> 4  0.3214638 0.04067210\n#> 5  0.4190199 0.04956667\n#> 6  0.7020633 0.03216789\n#> 7  0.6749959 0.04166325\n#> 8  0.1224306 0.03932716\n#> 9  0.5745258 0.04535562\n#> 10 0.2726013 0.04182736\n```\n:::\n\n\n\n## Simulating from sampling distributions \n\nWe can compare the two methods and see that we are sampling from the same data generation process.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nk <- 1e4\ns_umd <- sim_k_umd(k, D = 1, n1 = 50)\nip_umd <- replicate(k, sim_umd(n1 = 50, D = 1), simplify = FALSE)\nip_umd <- do.call(rbind, ip_umd)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](intro-meta-analysis_files/figure-revealjs/unnamed-chunk-18-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n## Simulating from sampling distributions \n\nThe actual advantage is in terms of computational speed. To simulate $k = 10$ studies for 1000 times (similar to a standard Monte Carlo simulation):\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbench <- microbenchmark::microbenchmark(\n  sampling = sim_k_umd(k = 10, n1 = 50, D = 1),\n  participant = replicate(10, sim_umd(n1 = 50, D = 1)),\n  times = 1000 \n)\n\n(bench <- summary(bench))\n#>          expr      min        lq      mean    median       uq      max neval\n#> 1    sampling  121.017  127.5495  147.8443  135.2085  145.162 5771.075  1000\n#> 2 participant 1546.187 1598.3900 1745.4717 1627.2745 1708.858 7836.305  1000\n#>   cld\n#> 1  a \n#> 2   b\n\nbench$mean[2] / bench$mean[1] # faster\n#> [1] 11.80615\n```\n:::\n\n\n\n## References {.refs}\n\n::: {#refs}\n:::\n",
    "supporting": [
      "intro-meta-analysis_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}